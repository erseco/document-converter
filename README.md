# Document Converter

A static microservice that uses ZetaJS (LibreOffice WASM) to convert documents in the browser. Supports deployment on Vercel and GitHub Pages.

## Features

- **Client-side document conversion** using LibreOffice WASM via ZetaJS
- **Iframe-compatible** with proper CORS and security headers for SharedArrayBuffer support
- **Multiple format support**: PDF, DOCX, XLSX, PPTX, ODT, ODS, ODP, HTML, TXT, RTF, PNG, JPG
- **Origin whitelist** optional security feature to restrict which domains can use the converter
- **GitHub Pages support** via Service Worker COOP/COEP headers and locally hosted WASM files

## Deployment

### Option 1: Vercel (Recommended)

Deploy to Vercel:

```bash
vercel
```

Or click the deploy button:

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/erseco/document-converter)

The Vercel deployment uses the ZetaOffice CDN for WASM files.

### Option 2: GitHub Pages

GitHub Pages deployment uses a GitHub Actions workflow to:
1. Download ZetaOffice WASM files from the CDN
2. Copy zetajs library files from npm
3. Deploy everything to GitHub Pages

**Setup:**
1. Enable GitHub Pages in your repository settings, using "GitHub Actions" as the source
2. The workflow will automatically run on push to `main` branch
3. Your converter will be available at `https://erseco.github.io/document-converter/`

**Files in the `docs/` folder:**
- `coi-serviceworker.js` - Service Worker that adds COOP/COEP headers
- `index.html` - Main page that loads the Service Worker and ZetaJS
- `converter.js` - Message handler for iframe communication

**Generated by GitHub Actions:**
- `wasm/` - ZetaOffice WASM files (soffice.js, soffice.wasm, soffice.data)
- `vendor/zetajs/` - zetajs library files (zeta.js, zetaHelper.js)

## Usage

### Direct URL Conversion (No Code Required)

You can convert documents directly via URL parameters without writing any code. This works on both `index.html` and `example.html`.

#### Convert from a Remote URL

```
https://erseco.github.io/document-converter/?url=https://example.com/document.docx
```

**Working examples** (using GitHub raw files which allow CORS):

- DOCX to PDF:
  ```
  https://erseco.github.io/document-converter/?url=https://raw.githubusercontent.com/AASJournals/aastex62-workshop/master/aastex-webinar.docx
  ```

- ODT to PDF:
  ```
  https://erseco.github.io/document-converter/?url=https://raw.githubusercontent.com/jgm/pandoc/main/test/odt/native/image.odt
  ```

- PPTX to PDF:
  ```
  https://erseco.github.io/document-converter/?url=https://raw.githubusercontent.com/jgm/pandoc/main/test/pptx/document-properties/document-properties.pptx
  ```

With auto-download:
```
https://erseco.github.io/document-converter/?url=https://raw.githubusercontent.com/AASJournals/aastex62-workshop/master/aastex-webinar.docx&download=true
```

Convert to a different format:
```
https://erseco.github.io/document-converter/?url=https://raw.githubusercontent.com/jgm/pandoc/main/test/odt/native/image.odt&format=docx
```

#### Convert from Base64 Data

For documents that can't be fetched via URL (due to CORS restrictions), you can pass the file content as Base64:

```
https://erseco.github.io/document-converter/?base64=UEsDBBQAAAA...&name=document.docx
```

With format and auto-download:
```
https://erseco.github.io/document-converter/?base64=UEsDBBQAAAA...&name=document.docx&format=pdf&download=true
```

#### URL Parameters Reference

| Parameter | Description | Required | Default |
|-----------|-------------|----------|---------|
| `url` | URL of the document to fetch and convert | Yes* | - |
| `base64` | Base64-encoded document content | Yes* | - |
| `name` | Filename (required with base64, optional with url) | Conditional | Extracted from URL |
| `format` | Output format: pdf, docx, xlsx, pptx, odt, ods, odp, html, txt, rtf | No | `pdf` |
| `download` | If "true", auto-download instead of preview | No | `false` |

*Either `url` or `base64` must be provided, but not both.

#### CORS Limitations

When using the `url` parameter, the remote server must allow CORS (Cross-Origin Resource Sharing) requests. If you get CORS errors:

1. **Use Base64**: Encode your file as Base64 and use the `base64` parameter
2. **Same-origin hosting**: Host your files on the same domain as the converter
3. **CORS proxy**: Use a CORS proxy server (for development only)

#### Example: Generate Conversion Link in JavaScript

```javascript
// Convert a file to Base64 and generate a conversion URL
async function getConversionUrl(file, format = 'pdf', autoDownload = false) {
    const arrayBuffer = await file.arrayBuffer();
    const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));

    const params = new URLSearchParams({
        base64: base64,
        name: file.name,
        format: format
    });

    if (autoDownload) {
        params.set('download', 'true');
    }

    return `https://erseco.github.io/document-converter/?${params.toString()}`;
}

// Usage
const file = document.querySelector('input[type="file"]').files[0];
const url = await getConversionUrl(file, 'pdf', true);
window.open(url, '_blank');
```

### Interactive Demo Page

The `example.html` page provides a full-featured interface with:
- Drag-and-drop file upload
- Format selection
- PDF preview
- Download button
- URL parameter support (same as above)

Access it at:
```
https://erseco.github.io/document-converter/example.html
```

### Embedding in an iframe

**Vercel deployment:**
```html
<iframe id="converter" src="https://your-vercel-deployment.vercel.app"></iframe>
```

**GitHub Pages deployment:**
```html
<iframe id="converter" src="https://erseco.github.io/document-converter/"></iframe>
```

### With origin whitelist (optional security)

To restrict which domains can communicate with the converter, add the `origins` query parameter:

```html
<iframe id="converter" src="https://your-vercel-deployment.vercel.app?origins=https://example.com,https://another.com"></iframe>
```

### Sending documents for conversion

```javascript
const iframe = document.getElementById('converter');

// Wait for the converter to be ready
window.addEventListener('message', (event) => {
    if (event.data.type === 'ready') {
        console.log('Converter is ready!');
    }
    
    if (event.data.type === 'result') {
        // Handle the converted blob
        const blob = event.data.blob;
        const url = URL.createObjectURL(blob);
        // Download or display the result
    }
    
    if (event.data.type === 'error') {
        console.error('Conversion error:', event.data.error);
    }
});

// Convert a document
async function convertDocument(file, format = 'pdf') {
    const arrayBuffer = await file.arrayBuffer();
    
    iframe.contentWindow.postMessage({
        type: 'convert',
        buffer: arrayBuffer,  // or 'file' for WordPress compatibility
        format: format,  // 'pdf', 'docx', 'xlsx', etc.
        requestId: Date.now()
    }, '*');
}
```

### WordPress Playground Integration

The GitHub Pages version is specifically designed to work as an isolated iframe within WordPress Playground:

```javascript
// In WordPress
const converterIframe = document.createElement('iframe');
converterIframe.src = 'https://erseco.github.io/document-converter/';
document.body.appendChild(converterIframe);

// Send file for conversion (supports both 'buffer' and 'file' property names)
converterIframe.contentWindow.postMessage({
    type: 'convert',
    file: arrayBuffer,  // ArrayBuffer of the document
    format: 'pdf',
    requestId: 'unique-id'
}, '*');

// Listen for results
window.addEventListener('message', (event) => {
    if (event.data.type === 'result') {
        const pdfBlob = event.data.blob;
        // Handle the converted PDF
    }
});
```

### Complete JavaScript Client Class

For production use, here's a robust wrapper class with error handling and timeouts:

```javascript
class DocumentConverterClient {
    constructor(iframeElement) {
        this.iframe = iframeElement;
        this.requestMap = new Map();
        this.isReady = false;
        this._initMessageListener();
    }

    _initMessageListener() {
        window.addEventListener('message', (event) => {
            const { type, requestId, blob, format, error, ready } = event.data;

            if (type === 'ready') {
                this.isReady = true;
                return;
            }

            if (type === 'pong') {
                this.isReady = ready;
                return;
            }

            if (requestId && this.requestMap.has(requestId)) {
                const { resolve, reject, timeoutId } = this.requestMap.get(requestId);
                clearTimeout(timeoutId);

                if (type === 'result') {
                    resolve({ blob, format });
                } else if (type === 'error') {
                    reject(new Error(error));
                }

                this.requestMap.delete(requestId);
            }
        });
    }

    /**
     * Wait for the converter to be ready
     * @param {number} timeout - Maximum wait time in milliseconds
     * @returns {Promise<void>}
     */
    waitForReady(timeout = 30000) {
        return new Promise((resolve, reject) => {
            if (this.isReady) {
                resolve();
                return;
            }

            const startTime = Date.now();
            const checkInterval = setInterval(() => {
                if (this.isReady) {
                    clearInterval(checkInterval);
                    resolve();
                } else if (Date.now() - startTime > timeout) {
                    clearInterval(checkInterval);
                    reject(new Error('Converter initialization timeout'));
                }
            }, 100);
        });
    }

    /**
     * Convert a document to the specified format
     * @param {ArrayBuffer} arrayBuffer - Document content as ArrayBuffer
     * @param {string} format - Target format (pdf, docx, xlsx, etc.)
     * @param {number} timeout - Conversion timeout in milliseconds
     * @returns {Promise<{blob: Blob, format: string}>}
     */
    convert(arrayBuffer, format = 'pdf', timeout = 120000) {
        return new Promise((resolve, reject) => {
            const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            const timeoutId = setTimeout(() => {
                this.requestMap.delete(requestId);
                reject(new Error(`Conversion timeout after ${timeout}ms`));
            }, timeout);

            this.requestMap.set(requestId, { resolve, reject, timeoutId });

            this.iframe.contentWindow.postMessage({
                type: 'convert',
                buffer: arrayBuffer,
                format: format,
                requestId: requestId
            }, '*');
        });
    }

    /**
     * Check if the converter is healthy
     * @returns {Promise<boolean>}
     */
    ping() {
        return new Promise((resolve) => {
            const requestId = `ping_${Date.now()}`;

            this.iframe.contentWindow.postMessage({
                type: 'ping',
                requestId: requestId
            }, '*');

            setTimeout(() => resolve(this.isReady), 1000);
        });
    }
}

// Usage example:
const iframe = document.getElementById('converter');
const converter = new DocumentConverterClient(iframe);

// Wait for initialization
await converter.waitForReady();

// Convert a file
const file = document.querySelector('input[type="file"]').files[0];
const arrayBuffer = await file.arrayBuffer();

try {
    const { blob } = await converter.convert(arrayBuffer, 'pdf');

    // Download the result
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'converted.pdf';
    link.click();
    URL.revokeObjectURL(url);
} catch (error) {
    console.error('Conversion failed:', error);
}
```

### Message Protocol Reference

#### Requests

| Type | Properties | Description |
|------|------------|-------------|
| `convert` | `buffer`, `format`, `requestId` | Convert document to specified format |
| `ping` | `requestId` | Check converter health |

#### Responses

| Type | Properties | Description |
|------|------------|-------------|
| `ready` | - | Converter has finished initializing |
| `result` | `blob`, `format`, `requestId` | Successful conversion result |
| `error` | `error`, `requestId` | Conversion error message |
| `pong` | `ready`, `requestId` | Health check response |

## Security Headers

### Vercel
The `vercel.json` configuration includes required headers for SharedArrayBuffer support:

- `Cross-Origin-Opener-Policy: same-origin`
- `Cross-Origin-Embedder-Policy: require-corp`
- `Content-Security-Policy` with `frame-ancestors *` to allow embedding

### GitHub Pages
The `coi-serviceworker.js` Service Worker adds the required headers via fetch interception:

- `Cross-Origin-Opener-Policy: same-origin`
- `Cross-Origin-Embedder-Policy: require-corp` (or `credentialless` as fallback)
- `Cross-Origin-Resource-Policy: cross-origin`

## Supported Formats

### Input formats
Any format supported by LibreOffice (DOC, DOCX, ODT, XLS, XLSX, ODS, PPT, PPTX, ODP, etc.)

### Output formats
- **PDF** - Portable Document Format
- **DOCX** - Microsoft Word
- **XLSX** - Microsoft Excel
- **PPTX** - Microsoft PowerPoint
- **ODT** - OpenDocument Text
- **ODS** - OpenDocument Spreadsheet
- **ODP** - OpenDocument Presentation
- **HTML** - Web page
- **TXT** - Plain text
- **RTF** - Rich Text Format
- **PNG** - Image
- **JPG** - Image

## License

MIT